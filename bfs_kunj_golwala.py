# -*- coding: utf-8 -*-
"""bfs_kunj_golwala.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J9WRV3qQxdOdLsxtUblQzjqn-ADmIXXt
"""

def move_right(node):
    return (node[0] + 1, node[1])

def move_left(node):
    return (node[0] - 1, node[1])

def move_up(node):
    return (node[0], node[1] + 1)

def move_down(node):
    return (node[0], node[1] - 1)

def move_up_right(node):
    return (node[0] + 1, node[1] + 1)

def move_up_left(node):
    return (node[0] - 1, node[1] + 1)

def move_down_right(node):
    return (node[0] + 1, node[1] - 1)

def move_down_left(node):
    return (node[0] - 1, node[1] - 1)

# Dictionary to map action names to functions
actions = {
    "right": move_right,
    "left": move_left,
    "up": move_up,
    "down": move_down,
    "up_right": move_up_right,
    "up_left": move_up_left,
    "down_right": move_down_right,
    "down_left": move_down_left,
}

def get_valid_moves(node):
    """
    Returns a list of new valid positions after applying all movement actions.
    """
    return [action(node) for action in actions.values()]

import cv2
import numpy as np
import queue
import os
import shutil
import matplotlib.pyplot as plt

# Define canvas dimensions
canvas_width = 250
canvas_height = 160


def is_inside_1(x, y, x0=230, y0=100, width=10, height=40, thickness=3):
    """
    Checks if a point (x, y) is inside the number "1" using half-planes.
    """
    # Vertical bar of "1"
    if x0 <= x <= x0 + thickness and y0 - height <= y <= y0:
        return True

    return False


def is_inside_6_second(x, y, x0=190, y0=100, large_radius=20, medium_radius=14, small_radius=8, hole_radius=5, thickness=3):
  top_x = x0 + medium_radius // 2  # Center slightly right
  top_y = y0 - large_radius * 1.5  # Positioned higher
  inside_top = ((x - top_x) ** 2 + (y - top_y) ** 2) <= small_radius ** 2 and x >= top_x

  mid_x = x0 + large_radius - thickness  # Positioned right
  mid_y = y0 - large_radius  # Centered in middle
  inside_middle = ((x - mid_x) ** 2 + (y - mid_y) ** 2) <= large_radius ** 2 and x <= mid_x

  bottom_x = x0 + medium_radius  # Center slightly right
  bottom_y = y0 - medium_radius  # Centered lower
  inside_bottom = ((x - bottom_x) ** 2 + (y - bottom_y) ** 2) <= medium_radius ** 2 and x >= bottom_x + thickness

  hole_x = x0 + medium_radius  # Centered horizontally
  hole_y = y0 - medium_radius  # Centered vertically
  inside_hole = ((x - hole_x) ** 2 + (y - hole_y) ** 2) <= hole_radius ** 2  # Inside hole

  if (inside_top or inside_middle or inside_bottom) and not inside_hole:
    return True

  return False

def is_inside_6_first(x, y, x0=145, y0=100, large_radius=20, medium_radius=14, small_radius=8, hole_radius=5, thickness=3):
    """
    Checks if a point (x, y) is inside the number "6" using a series of connected semi-circles
    with correct radius proportions and a small hole in the center.
    """
    top_x = x0 + medium_radius // 2  # Center slightly right
    top_y = y0 - large_radius * 1.5  # Positioned higher
    inside_top = ((x - top_x) ** 2 + (y - top_y) ** 2) <= small_radius ** 2 and x >= top_x

    mid_x = x0 + large_radius - thickness  # Positioned right
    mid_y = y0 - large_radius  # Centered in middle
    inside_middle = ((x - mid_x) ** 2 + (y - mid_y) ** 2) <= large_radius ** 2 and x <= mid_x

    bottom_x = x0 + medium_radius  # Center slightly right
    bottom_y = y0 - medium_radius  # Centered lower
    inside_bottom = ((x - bottom_x) ** 2 + (y - bottom_y) ** 2) <= medium_radius ** 2 and x >= bottom_x + thickness

    hole_x = x0 + medium_radius  # Centered horizontally
    hole_y = y0 - medium_radius  # Centered vertically
    inside_hole = ((x - hole_x) ** 2 + (y - hole_y) ** 2) <= hole_radius ** 2  # Inside hole

    if (inside_top or inside_middle or inside_bottom) and not inside_hole:
        return True

    return False

def is_inside_M(x, y, x0=100, y0=100, width=30, height=40, thickness=3):
    """
    Checks if a point (x, y) is inside the letter "M" using half-planes, matching the given shape.
    """
    # Left vertical bar
    if x0 <= x <= x0 + thickness and y0 - height <= y <= y0:
        return True

    # Right vertical bar
    if x0 + width - thickness <= x <= x0 + width and y0 - height <= y <= y0:
        return True

    # Left diagonal (bottom-left to middle-bottom)
    slope_left = (height / 2) / (width / 2 - thickness)
    y_expected_left = slope_left * (x - x0 - thickness) + (y0 - height)

    if x0 + thickness <= x <= x0 + width / 2 and y_expected_left  <= y <= y_expected_left + 10:
        return True

    # Right diagonal (middle-bottom to bottom-right)
    slope_right = (-height / 2) / (width / 2 - thickness)
    y_expected_right = slope_right * (x - (x0 + width / 2)) + (y0 - height / 2)

    if x0 + width / 2 <= x <= x0 + width - thickness and y_expected_right <= y <= y_expected_right + 10:
        return True

    return False

def is_inside_P(x, y, x0=80, y0=100, width=20, height=40, thickness=3, curve_radius=0):
    """
    Checks if a point (x, y) is inside the letter "P" using half-planes and a circular section.
    """
    # Left vertical bar
    if x0 <= x <= x0 + thickness and y0 - height <= y <= y0:
          return True

    # Approximating the curved section using a bounding box (semi-circle)
    curve_x_center = x0 + thickness
    curve_y_center = y0 - (3 * height / 4)  # Approximate center of the curve
    curve_radius = height / 4
    # Circular region approximation for "P"
    if ((x - curve_x_center) ** 2 + (y - curve_y_center) ** 2) <= curve_radius ** 2 and y < y0 - height // 2 and x> x0 + thickness:
        return True

    return False


def is_inside_N(x, y, x0=50, y0=100, width=20, height=40, thickness=3):
    """
    Checks if a point (x, y) is inside the letter "N" using half-planes.
    """
    # Left vertical bar
    if x0 <= x <= x0 + thickness and y0 - height <= y <= y0:
        return True

    # Right vertical bar
    if x0 + width - thickness <= x <= x0 + width and y0 - height <= y <= y0:
        return True

    # Diagonal connecting top-left to bottom-right
    slope = (2/3)*height / (width - 2 * thickness)
    y_expected = (slope * (x - (x0 + thickness))) + (y0 - height)

    if x0 + thickness <= x <= x0 + width - thickness and y_expected <= y <= y_expected + height/3:
        return True

    return False

# Define the letter "E" using half-planes
def is_inside_E(x, y, x0=20, y0=100, width=20, height=40, mid_width=15, thickness=3):
    """
    Checks if a point (x, y) is inside the letter "E" using half-planes.
    """
    # Define the main vertical bar
    if x0 <= x <= x0 + thickness and y0 - height <= y <= y0:
        return True

    # Define the top horizontal bar
    if x0 <= x <= x0 + width and y0 - height <= y <= y0 - height + thickness:
        return True

    # Define the middle horizontal bar (shorter)
    if x0 <= x <= x0 + mid_width and y0 - height // 2 - thickness // 2 <= y <= y0 - height // 2 + thickness // 2:
        return True

    # Define the bottom horizontal bar
    if x0 <= x <= x0 + width and y0 - thickness <= y <= y0:
        return True

    return False

# Define clearance around the obstacle
clearance = 2

# Generate obstacle and clearance mask
def generate_obstacles(grid_width, grid_height, clearance):
    """
    Creates an obstacle mask for the letters "E" and "N" with a distinct clearance region.
    """
    obstacle_mask = np.zeros((grid_height, grid_width), dtype=np.uint8)
    clearance_mask = np.zeros((grid_height, grid_width), dtype=np.uint8)

    for y in range(grid_height):
        for x in range(grid_width):
            if is_inside_E(x, y) or is_inside_N(x, y) or is_inside_P(x,y) or is_inside_M(x,y) or is_inside_6_first(x,y) or is_inside_6_second(x,y) or is_inside_1(x,y):
              obstacle_mask[y, x] = 255  # Mark obstacle pixels

    # Expand the clearance region using OpenCV dilation
    kernel = np.ones((clearance * 2 + 1, clearance * 2 + 1), np.uint8)
    clearance_mask = cv2.dilate(obstacle_mask, kernel, iterations=1)

    # Ensure obstacle remains distinct inside clearance
    clearance_mask[np.where(obstacle_mask == 255)] = 200  # Assign a different value

    return obstacle_mask, clearance_mask

# Generate the updated masks
obstacle_mask, clearance_mask = generate_obstacles(canvas_width, canvas_height, clearance)

# BFS Algorithm with Half-Plane Obstacle Avoidance
def bfs(start, goal, grid_width, grid_height, clearance_mask):
    """
    Performs BFS while ensuring NO exploration inside the mathematically defined obstacle space.
    """
    q = queue.Queue()
    visited = set()
    parent_map = {}
    explored_nodes = []

    q.put(start)
    visited.add(start)

    # Movement actions (8-connected)
    actions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,1), (1,-1), (-1,-1)]

    while not q.empty():
        current = q.get()

        # Skip nodes inside the obstacle or clearance
        if clearance_mask[current[1], current[0]] == 255:  # Mask is white where obstacles exist
            continue

        explored_nodes.append(current)

        # Check if we reached the goal
        if current == goal:
            optimal_path = []
            while current in parent_map:
                optimal_path.append(current)
                current = parent_map[current]
            optimal_path.append(start)
            optimal_path.reverse()
            return optimal_path, explored_nodes

        # Expand neighbors
        for dx, dy in actions:
            new_x, new_y = current[0] + dx, current[1] + dy
            new_node = (new_x, new_y)

            if (new_node not in visited and
                0 <= new_x < grid_width and 0 <= new_y < grid_height and
                clearance_mask[new_y, new_x] == 0):  # Ensure new node is not in obstacle

                q.put(new_node)
                visited.add(new_node)
                parent_map[new_node] = current

    return None, explored_nodes

# BFS Visualization with distinct colors
def visualize_bfs(grid_width, grid_height, explored_nodes, optimal_path, clearance_mask, obstacle_mask):
    """
    Uses OpenCV to visualize BFS exploration, ensuring obstacle and clearance have distinct colors.
    """
    # Create a blank white canvas
    canvas = np.ones((grid_height, grid_width, 3), dtype=np.uint8) * 255

    # Draw clearance (Green)
    canvas[np.where(clearance_mask == 255)] = [0, 255, 0]  # Green for clearance

    # Draw obstacle (Red)
    canvas[np.where(obstacle_mask == 255)] = [255, 0, 0]  # Red for obstacle

    # Draw start and goal points
    cv2.circle(canvas, start_position, 1, (0,0, 0), -1)  # Green for start
    cv2.circle(canvas, goal_position, 1, (0, 0, 0), -1)  # Red for goal

    # Directory to save frames
    frame_dir = "bfs_frames"
    os.makedirs(frame_dir, exist_ok=True)

    frame_index = 0


    # Plot explored nodes first (Blue)
    for i, node in enumerate(explored_nodes):
      cv2.circle(canvas, node, 1, (0, 0, 255), -1)  # Blue for explored nodes
      cv2.imwrite(f"{frame_dir}/frame_{frame_index:04d}.png", canvas)
      frame_index += 1

    # Plot the shortest path after all exploration is done (Yellow)
    if (len(optimal_path) == 0):
      print("No valid path found.Re rerun the code with valid goal corrdinates")
      return None
    for i, node in enumerate(optimal_path):
      cv2.circle(canvas, node, 2, (0, 255, 255), -1)  # Yellow for the optimal path
      cv2.imwrite(f"{frame_dir}/frame_{frame_index:04d}.png", canvas)
      frame_index += 1

    # Convert images to video with reduced frame rate
    video_path = "bfs.mp4"
    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
    video = cv2.VideoWriter(video_path, fourcc, 400, (grid_width, grid_height))

    for i in range(frame_index):
        frame = cv2.imread(os.path.join(frame_dir, f"frame_{i:04d}.png"))
        video.write(frame)

    video.release()

    return video_path


input_signal_start = True

while input_signal_start:
  start_x = int(input("X coordinate of start position:"))
  start_y = int(input("Y coordinate of start position:"))
  if(clearance_mask[start_y][start_x] == 200 or clearance_mask[start_y][start_x] == 255):
    print("Start position is inside an obstacle. Please enter a new start value!")
    continue
  elif(start_x<0 or start_y<0 or start_x>canvas_width or start_y>canvas_height):
    print("Start position is outside the canvas. Please enter a new start value!")
    continue
  else:
    break

input_signal_goal = True

while(input_signal_goal):
  goal_x = int(input("X coordinate of goal position:"))
  goal_y = int(input("Y coordinate of goal position:"))
  if(clearance_mask[goal_y][goal_x] == 200 or clearance_mask[goal_y][goal_x] == 255):
    print("Goal position is inside an obstacle. Please enter a new goal value!")
    continue
  elif(goal_x<0 or goal_y<0 or goal_x>canvas_width or goal_y>canvas_height):
    print("Goal position is outside the canvas. Please enter a new goal value!")
    continue
  else:
    break

start_position = (start_x, start_y)
goal_position = (goal_x, goal_y)
start_position = (start_position[0] , canvas_height - start_position[1])
goal_position = (goal_position[0] , canvas_height - goal_position[1])
# Run BFS with mathematically defined obstacles
path_result, explored_nodes = bfs(start_position, goal_position, canvas_width, canvas_height, clearance_mask)

# Generate BFS visualization using updated obstacle and clearance representation
video_file = visualize_bfs(canvas_width, canvas_height, explored_nodes, path_result, clearance_mask, obstacle_mask)

print("BFS visualization saved as bfs.mp4!")

import matplotlib.pyplot as plt

def plot_final_trajectory(grid_width, grid_height, optimal_path, clearance_mask, obstacle_mask):
    """
    Plots the final BFS trajectory on a Matplotlib figure with obstacles and clearance.
    """
    fig, ax = plt.subplots(figsize=(9, 5))
    flipped_clearance = cv2.flip(clearance_mask, 0)
    flipped_obstacle = cv2.flip(obstacle_mask, 0)
    # Create a blank image for visualization
    img = np.ones((grid_height, grid_width, 3), dtype=np.uint8) * 255

    # Color the clearance area (green)
    img[np.where(flipped_clearance == 255)] = [0, 255, 0]  # Green for clearance

    # Color the obstacles (red)
    img[np.where(flipped_obstacle == 255)] = [255, 0, 0]  # Red for obstacle

    # Convert image to correct format for Matplotlib
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Display the obstacle and clearance
    ax.imshow(img)

    # Plot the final trajectory (yellow line)
    if optimal_path:
        x_coords, y_coords = zip(*optimal_path)
        ax.plot(x_coords, [grid_height - y for y in y_coords], color='yellow', linewidth=2, label="Optimal Path")

    # Start and goal markers
    ax.scatter(start_position[0], grid_height - start_position[1], color='green', s=50, label="Start")
    ax.scatter(goal_position[0], grid_height - goal_position[1], color='red', s=50, label="Goal")

    # Labels and formatting
    ax.set_title("Final BFS Trajectory")
    ax.set_xlabel("Width (mm)")
    ax.set_ylabel("Height (mm)")
    ax.legend()
    ax.invert_yaxis()
    ax.grid(True, linestyle="--", linewidth=0.5)

    # Show the plot
    plt.show()

# Call the function after BFS execution
if path_result:
    plot_final_trajectory(canvas_width, canvas_height, path_result, clearance_mask, obstacle_mask)
else:
    print("No valid path found!")